<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple Pong</title>
  <link rel="stylesheet" href="styles.css">
</head>
<style>
:root{
  --bg:#0b1220;
  --panel:#0f1724;
  --accent:#9ad3ff;
  --muted:#9aa7b2;
  --text:#e6f0f6;
}

*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
.container{max-width:900px;margin:32px auto;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,0.7);text-align:center}
h1{margin:0 0 12px;font-weight:600}
canvas{background:var(--panel);display:block;margin:14px auto;border-radius:6px;box-shadow:0 6px 30px rgba(0,0,0,0.6);cursor:crosshair}
.controls{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px}
button{background:var(--accent);border:0;padding:8px 12px;border-radius:6px;color:#021025;font-weight:600;cursor:pointer}
button:hover{opacity:0.95}
label{color:var(--muted);font-size:0.95rem}
footer{margin-top:10px;color:var(--muted)}



</style>
<body>
  <div class="container">
    <h1>Simple Pong</h1>
    <canvas id="game" width="800" height="500"></canvas>
    <div class="controls">
      <button id="restart">Restart</button>
      <label>Left paddle: mouse or ↑/↓</label>
    </div>
    <footer>
      <small>Made with HTML, CSS, and JavaScript</small>
    </footer>
  </div>
  
  <script>
// Simple Pong game
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;

// Paddle properties
const PADDLE_WIDTH = 12;
const PADDLE_HEIGHT = 110;
const PADDLE_SPEED = 6;

// Ball properties
const BALL_RADIUS = 8;
let ballSpeed = 5;

// Game state
let leftScore = 0;
let rightScore = 0;
let isPaused = false;

// Left (player) paddle
const leftPaddle = {
  x: 10,
  y: (H - PADDLE_HEIGHT) / 2,
  w: PADDLE_WIDTH,
  h: PADDLE_HEIGHT,
  dy: 0
};

// Right (computer) paddle
const rightPaddle = {
  x: W - PADDLE_WIDTH - 10,
  y: (H - PADDLE_HEIGHT) / 2,
  w: PADDLE_WIDTH,
  h: PADDLE_HEIGHT
};

// Ball
const ball = {
  x: W / 2,
  y: H / 2,
  r: BALL_RADIUS,
  vx: 0,
  vy: 0
};

function resetBall(toRight = Math.random() > 0.5) {
  ball.x = W / 2;
  ball.y = H / 2;
  ballSpeed = 5;
  const angle = (Math.random() * Math.PI / 4) - (Math.PI / 8); // -22.5deg .. 22.5deg
  ball.vx = (toRight ? 1 : -1) * Math.cos(angle);
  ball.vy = Math.sin(angle);
}

// Start initial ball
resetBall();

// Draw helper functions
function drawRect(x, y, w, h, color = '#fff') {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, w, h);
}

function drawCircle(x, y, r, color = '#fff') {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();
}

function drawMiddleLine() {
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 12]);
  ctx.beginPath();
  ctx.moveTo(W / 2, 0);
  ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawScores() {
  ctx.fillStyle = '#9ad3ff';
  ctx.font = '36px system-ui,Segoe UI,Arial';
  ctx.textAlign = 'center';
  ctx.fillText(leftScore, W / 2 - 60, 60);
  ctx.fillText(rightScore, W / 2 + 60, 60);
}

// Update logic
let keys = { ArrowUp: false, ArrowDown: false };

document.addEventListener('keydown', (e) => {
  if (e.key === ' '){ // pause with space
    isPaused = !isPaused;
    e.preventDefault();
    return;
  }
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    keys[e.key] = true;
    e.preventDefault();
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    keys[e.key] = false;
    e.preventDefault();
  }
});

// Mouse controls left paddle
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const y = e.clientY - rect.top;
  leftPaddle.y = y - leftPaddle.h / 2;
  clampPaddles();
});

// Keep paddles inside
function clampPaddles() {
  leftPaddle.y = Math.max(0, Math.min(H - leftPaddle.h, leftPaddle.y));
  rightPaddle.y = Math.max(0, Math.min(H - rightPaddle.h, rightPaddle.y));
}

// Simple AI for right paddle
function updateAI() {
  const targetY = ball.y - rightPaddle.h / 2;
  const diff = targetY - rightPaddle.y;
  const aiSpeed = 4; // tweak difficulty
  if (Math.abs(diff) > aiSpeed) {
    rightPaddle.y += diff > 0 ? aiSpeed : -aiSpeed;
  } else {
    rightPaddle.y += diff;
  }
  clampPaddles();
}

// Collision detection between ball and a paddle
function paddleCollision(p) {
  // AABB vs circle roughly
  const nearestX = Math.max(p.x, Math.min(ball.x, p.x + p.w));
  const nearestY = Math.max(p.y, Math.min(ball.y, p.y + p.h));
  const dx = ball.x - nearestX;
  const dy = ball.y - nearestY;
  return (dx * dx + dy * dy) <= (ball.r * ball.r);
}

function update() {
  if (isPaused) return;

  // Keyboard paddle movement
  if (keys.ArrowUp) leftPaddle.y -= PADDLE_SPEED;
  if (keys.ArrowDown) leftPaddle.y += PADDLE_SPEED;
  clampPaddles();

  // Update AI
  updateAI();

  // Move ball
  ball.x += ball.vx * ballSpeed;
  ball.y += ball.vy * ballSpeed;

  // Top/bottom collision
  if (ball.y - ball.r <= 0) {
    ball.y = ball.r;
    ball.vy = -ball.vy;
  } else if (ball.y + ball.r >= H) {
    ball.y = H - ball.r;
    ball.vy = -ball.vy;
  }

  // Paddle collisions
  // Left paddle
  if (ball.x - ball.r <= leftPaddle.x + leftPaddle.w) {
    if (paddleCollision(leftPaddle) && ball.vx < 0) {
      // Calculate where it hit the paddle to change angle
      const collidePoint = (ball.y - (leftPaddle.y + leftPaddle.h / 2)) / (leftPaddle.h / 2);
      const angle = collidePoint * (Math.PI / 4); // max 45 degrees
      const direction = 1;
      ball.vx = direction * Math.cos(angle);
      ball.vy = Math.sin(angle);
      ballSpeed = Math.min(12, ballSpeed + 0.4); // speed up a bit
      ball.x = leftPaddle.x + leftPaddle.w + ball.r + 0.5; // prevent stuck
    }
  }

  // Right paddle
  if (ball.x + ball.r >= rightPaddle.x) {
    if (paddleCollision(rightPaddle) && ball.vx > 0) {
      const collidePoint = (ball.y - (rightPaddle.y + rightPaddle.h / 2)) / (rightPaddle.h / 2);
      const angle = collidePoint * (Math.PI / 4);
      const direction = -1;
      ball.vx = direction * Math.cos(angle);
      ball.vy = Math.sin(angle);
      ballSpeed = Math.min(12, ballSpeed + 0.4);
      ball.x = rightPaddle.x - ball.r - 0.5;
    }
  }

  // Score: left missed
  if (ball.x + ball.r < 0) {
    rightScore += 1;
    resetBall(true);
  } else if (ball.x - ball.r > W) {
    leftScore += 1;
    resetBall(false);
  }
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, W, H);
  drawMiddleLine();

  // paddles
  drawRect(leftPaddle.x, leftPaddle.y, leftPaddle.w, leftPaddle.h, '#9ad3ff');
  drawRect(rightPaddle.x, rightPaddle.y, rightPaddle.w, rightPaddle.h, '#9ad3ff');

  // ball
  drawCircle(ball.x, ball.y, ball.r, '#fff');

  // scores
  drawScores();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Restart button
document.getElementById('restart').addEventListener('click', () => {
  leftScore = 0;
  rightScore = 0;
  leftPaddle.y = (H - leftPaddle.h) / 2;
  rightPaddle.y = (H - rightPaddle.h) / 2;
  resetBall();
  isPaused = false;
});

// Start the loop
loop();
















  </script>












</body>
</html>